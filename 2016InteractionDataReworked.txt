-- Caleb's Interaction Data REWORKED. This interaction data will probably work w/ the server (possibly)
-- This will be for everything around the map. The old interaction data was MESSED UP.

local module = {}

-- Services
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer
local repStorage = game:GetService("ReplicatedStorage")
local modules = repStorage:WaitForChild("Modules")
local marketplaceService = game:GetService("MarketplaceService")
local plots = workspace:WaitForChild("Plots")

-- Loader
local function load(moduleInstance)
	local loaded
	task.spawn(function()
		task.wait(1)
		assert(loaded, "Unable to load " .. tostring(moduleInstance and moduleInstance:GetFullName() or moduleInstance))
	end)
	loaded = require(moduleInstance)
	return loaded
end

-- Core Modules
local attachHandler = load(modules:WaitForChild("AttachHandler"))
local animationHandler = load(modules:WaitForChild("AnimationHandler"))
local vehicleHandler = load(modules:WaitForChild("VehicleHandler"))
local plotHandler = load(modules:WaitForChild("PlotHandler"))
--local itemHandler = load(modules:WaitForChild("Items"))
local equipmentHandler = require(modules:WaitForChild("EquipmentHandler"))
local items = load(modules:WaitForChild("Items"))
local dataManager = load(modules:WaitForChild("DataManager"))
local foodData = load(modules:WaitForChild("FoodData"))
local partAlign = load(modules:WaitForChild("PartAlign"))
local textModule = load(modules:WaitForChild("TextModule"))
local permissionHandler = load(modules:WaitForChild("PermissionHandler"))

-- Local GUI Modules
local localModules = {}
if localPlayer then
	local GUI = localPlayer:WaitForChild("PlayerGui")
	local guiModules = GUI:WaitForChild("Modules")

	for _, name in pairs({
		"GUIHandler",
		"ClientStats",
		"ProductPurchaser",
		"NotificationHandler",
		"OptionsHandler",
		"Inventory"
		}) do
		localModules[name] = load(guiModules:WaitForChild(name))
	end
end

-- Interaction Type Fetcher
function module:GetInteractionType(object)
	if not object then return nil end
	if object:IsA("Player") then
		return "Player"
	end
	if object:FindFirstChild("InteractionType") then
		return object.InteractionType.Value
	elseif object:FindFirstChild("Type") then
		return object.Type.Value
	end
	return nil
end

-- Interaction Handler
function module:HandleInteraction(object)
	local interactionType = self:GetInteractionType(object)
	if not interactionType then
		warn("No valid interaction type for object:", object)
		return
	end

	if interactionType == "Player" then
		self:HandlePlayerInteraction(object)
	elseif interactionType == "Vehicle" then
		self:HandleVehicleInteraction(object)
	elseif interactionType == "Shop" then
		self:HandleShopInteraction(object)
	elseif interactionType == "Plot" then
		self:HandlePlotInteraction(object)
	elseif interactionType == "Item" then
		self:HandleItemInteraction(object)
	else
		warn("Unknown interaction type:", interactionType)
	end
end

-- Specific Handlers
function module:HandlePlayerInteraction(player)
	if not player or not player:IsA("Player") then return end
	localModules.GUIHandler:OpenPlayerProfile(player)
end

function module:HandleVehicleInteraction(vehicle)
	if not vehicle then return end
	vehicleHandler:EnterVehicle(vehicle)
end

function module:HandleShopInteraction(shop)
	if not shop then return end
	localModules.GUIHandler:OpenShop(shop)
end

function module:HandlePlotInteraction(plot)
	if not plot then return end
	plotHandler:ClaimPlot(plot)
end

function module:HandleItemInteraction(item)
	if not item then return end
	--itemHandler:PickupItem(item)
	print("Unfourtanely we couldn't find the item handler, so you cant pick up")
	local guihandler = game.Players.LocalPlayer.PlayerGui.Modules:WaitForChild("GUIHandler")
	guihandler.AlertBox("You can't pick up items yet!", "You can't pick up items yet!")
end



-- Additional modules
--do
--	local serverModules = game:GetService("ServerStorage"):WaitForChild("Modules")

--	task.spawn(function()
--		for _, name in pairs({"1", "2", "3"}) do
--			localModules[name] = load(serverModules:WaitForChild(name))
--		end
--	end)
--end



-- New IndexData function
function module:IndexData(data, path)
	if not data then return end

	local curData = data
	local curIndex = ""
	local curText = nil
	local curPermission = 0

	for index in string.gmatch(path, "%d+") do
		curIndex = index
		local newData = curData[tonumber(index)]
		if type(newData) == "function" then
			local text, permission, foundData = newData()
			if foundData then
				curData = foundData
				curText = text
				curPermission = permission
			else
				break
			end
		else
			break
		end
	end

	return curData, curIndex, curText, curPermission
end

-- Local helper functions
local function takeAnimation(plr)
	local animation = animationHandler:PlayAnimation(plr.Character, "TakeItem")
	delay(animation.Fade, function()
		animationHandler:StopAnimation(plr.Character, animation.Name)
	end)
end

local function buyItem(plr, object, price)
	if price <= localModules.StatHandler:GetStat(plr, "Money") then
		local model = equipmentHandler:EquipItem(plr, object)
		if model then
			localModules.StatHandler:ChangeStat(plr, "Money", -price)
		end
	end
end

-- New GetData function
function module:GetData(object, player, menu)
	if not object then return end

	local interactionType = self:GetInteractionType(object)

	if interactionType == "Default" then
		return {
			function()
				return "Test", 0, function()
					print("Hello World")
					return "Close"
				end
			end,
			function()
				if game.Lighting.Outlines then
					return "Disable Outlines", 0, function()
						game.Lighting.Outlines = false
						return "Update"
					end, { Color = Color3.new(0.333, 1, 0) }
				else
					return "Enable Outlines", 0, function()
						game.Lighting.Outlines = true
						return "Update"
					end, { Color = Color3.new(1, 0, 0) }
				end
			end,
			function()
				local data = {}
				for i = 1, math.random(8, 30) do
					table.insert(data, function()
						return "Option" .. tostring(i):rep(math.random(10)), 0, function()
							print("Option" .. i)
						end
					end)
				end
				return "Do stuff...", 0, data
			end
		}

	elseif interactionType == "Lighting" then
		local data = object:WaitForChild("ObjectData")
		return {
			function()
				return "Switch " .. (data.IsOn.Value and "Off" or "On"), 1, function(isServer)
					data.IsOn.Value = not data.IsOn.Value
					if not isServer then
						object.PrimaryPart:WaitForChild("Click"):Play()
						takeAnimation(player)
						return "Update"
					end
				end
			end
		}

	elseif interactionType == "LightSwitch" then
		local plot = plotHandler:GetPlotFromModel(object)
		local foundLights = {}

		local function updateLights()
			if object and object.Parent and object.Parent.Parent then
				local sizeBox = object.Parent.Parent:FindFirstChild("SizeBox")
				-- Logic for finding lights (expand if needed)
			end
		end

		return {
			function()
				if #foundLights == 0 then
					updateLights()
				end
				if #foundLights > 0 then
					local isOn = foundLights[1]:WaitForChild("ObjectData"):WaitForChild("IsOn").Value
					return "Switch " .. (isOn and "Off" or "On"), 1, function(isServer)
						for _, light in pairs(foundLights) do
							light.ObjectData.IsOn.Value = not isOn
						end
						if not isServer then
							object.PrimaryPart:WaitForChild("Click"):Play()
							takeAnimation(player)
							return "Update"
						end
					end
				end
			end
		}

	elseif interactionType == "TV" then
		local data = object:WaitForChild("ObjectData")
		return {
			function()
				local isOn = data.IsOn.Value
				return "Turn " .. (isOn and "Off" or "On"), 1, function(isServer)
					data.IsOn.Value = not isOn
					if not isServer then
						takeAnimation(player)
						return "Update"
					end
				end
			end,
			-- Other TV interactions (Change Channel, Watch)
		}

	elseif interactionType == "TVRemote" then
		local tv, tvDistance = nil, nil

		local function checkTV(obj)
			local intType = obj:FindFirstChild("InteractionType")
			if intType and intType.Value == "TV" then
				local distance = (obj.PrimaryPart.Position - object.PrimaryPart.Position).Magnitude
				if not tv or distance < tvDistance then
					tv = obj
					tvDistance = distance
				end
			end
		end

		local plot = plotHandler:GetPlotFromModel(object)
		local house = plot:WaitForChild("House")
		for _, catModel in pairs(house:GetChildren()) do
			for _, obj in pairs(catModel:GetChildren()) do
				checkTV(obj)
			end
		end

		if tv then
			return self:GetData(tv, player)
		else
			return {
				function()
					return "No nearby TV!", 0, function()
						return "Close"
					end
				end
			}
		end

	elseif interactionType == "Computer" then
		local data = object:WaitForChild("ObjectData")
		return {
			function()
				return "Use", 2, function(isServer)
					if not isServer then
						spawn(function()
							localModules.PlaylistHandler:ShowPlaylistFrame(object)
						end)
						return "Close"
					end
				end
			end
		}
	elseif interactionType == "Doors" then
		local data = object:WaitForChild("ObjectData")
		return {
			function()
				local isOpen = data.IsOpen.Value
				return isOpen and "Close" or "Open", 1, function(isServer)
					data.IsOpen.Value = not isOpen
					if not isServer then
						takeAnimation(player)
						return "Close"
					end
				end
			end
		}
	elseif interactionType == "Chairs" or interactionType == "Comfort" or interactionType == "Stool" or interactionType == "FerrisWheelSeat" or interactionType == "SunChair" then
		return {
			function()
				return "Sit", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name)

						if interactionType == "FerrisWheelSeat" and object.PrimaryPart then
							attachHandler:MovePlayer(player, object.PrimaryPart.CFrame * CFrame.new(0, 3, 0))
						end

						local attachData = attachHandler:Attach(object, player.Character, true)
						if attachData then
							-- Handle animations
							if object.Name:match("Rocking Chair") then
								animationHandler:PlayAnimation(player.Character, "RockingChair")
								animationHandler:PlayObjectAnimation(attachData.Model, "RockingChair")
							elseif interactionType == "SunChair" and object.Name ~= "Deck Chair" then
								animationHandler:PlayAnimation(player.Character, "SitSunChair")
							else
								animationHandler:PlayAnimation(player.Character, interactionType == "Stool" and "SitStool" or "Sit")
							end

							-- Handle status
							local status
							if interactionType == "FerrisWheelSeat" then
								status = localModules.StatHandler:AddStatus(player, {
									Name = "Ferris Wheel",
									Color = "Glad",
									Icon = 479032025,
									Description = "This is fun!"
								}, { Energy = 1, Fun = 2 })
							else
								local comfort = (itemData and itemData.Stats and itemData.Stats.Comfort) or 0
								local description = "Ahh, what could be better than just laying in the sun?"
								local icon = (interactionType ~= "SunChair" and itemData and itemData.Icon) or ""

								status = localModules.StatHandler:AddStatus(player, {
									Name = "Relaxing in the sun",
									Color = "Glad",
									Icon = icon,
									Description = description
								}, { Energy = 0.5 + comfort * 0.2 })
							end

							-- Always add 'Comfy' status
							localModules.StatHandler:AddStatus(player, {
								Name = "Comfy",
								Color = "Glad",
								Icon = itemData and itemData.Icon or "",
								Description = "Taking a quick rest can sometimes be quite nice."
							}, { Energy = 0.5 + ((itemData and itemData.Stats and itemData.Stats.Comfort) or 0) * 0.2 })

							-- Wait for detach, then remove status
							attachData.Detached:Wait()
							if status then
								status:Remove()
							end

							-- Stop animations
							if object.Name:match("Rocking Chair") then
								animationHandler:StopAnimation(player.Character, "RockingChair")
								animationHandler:StopObjectAnimation(attachData.Model)
							elseif interactionType == "SunChair" and object.Name ~= "Deck Chair" then
								animationHandler:StopAnimation(player.Character, "SitSunChair")
							else
								animationHandler:StopAnimation(player.Character, interactionType == "Stool" and "SitStool" or "Sit")
							end
						end
					else
						return "Close"
					end
				end
			end
		}
		
	elseif interactionType == "Beds" then
		return {
			function()
				return "Sleep", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name, interactionType)
						if itemData then
							local attachData = attachHandler:Attach(object, player.Character)
							if attachData then
								equipmentHandler:UnequipItem(player)
								animationHandler:PlayAnimation(player.Character, "Sleep")

								local status = localModules.StatHandler:AddStatus(player, {
									Name = "Lost in Dreams",
									Color = "Glad",
									Icon = itemData.Icon,
									Description = "Sleeping like a log."
								}, {
									Energy = 2 + ((itemData.Stats and itemData.Stats.Comfort) or 0) * 0.3
								})

								attachData.Detached:Wait()
								status:Remove()
								animationHandler:StopAnimation(player.Character, "Sleep")
							end
						end
					else
						return "Close"
					end
				end
			end
		}

	elseif interactionType == "Toilet" then
		return {
			function()
				return "Use", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name)
						if itemData then
							local attachData = attachHandler:Attach(object, player.Character, true)
							if attachData then
								animationHandler:PlayAnimation(player.Character, "Sit")

								local status = localModules.StatHandler:AddStatus(player, {
									Name = "Ahh...",
									Color = "Great",
									Icon = itemData.Icon,
									Description = "Guess it went down the toilet."
								}, {
									Hygiene = 2 + ((itemData.Stats and itemData.Stats.Hygiene) or 0) * 0.2,
									Energy = ((itemData.Stats and itemData.Stats.Comfort) or 0) * 0.1
								})

								attachData.Detached:Wait()
								status:Remove()

								local flushSound = object.PrimaryPart:WaitForChild("Flush")
								flushSound:Play()
								delay(4, function()
									flushSound:Stop()
								end)

								animationHandler:StopAnimation(player.Character, "Sit")
							end
						end
					else
						return "Close"
					end
				end
			end
		}

	elseif interactionType == "Bathtub" then
		return {
			function()
				return "Bathe", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name)
						if itemData then
							local attachData = attachHandler:Attach(object, player.Character)
							if attachData then
								equipmentHandler:UnequipItem(player)
								animationHandler:PlayAnimation(player.Character, "Bath")

								local status = localModules.StatHandler:AddStatus(player, {
									Name = "Relaxing Bath",
									Color = "Glad",
									Icon = itemData.Icon,
									Description = "Nothing beats a warm and relaxing afternoon bath."
								}, {
									Hygiene = 2 + ((itemData.Stats and itemData.Stats.Hygiene) or 0) * 0.25,
									Energy = 0.4 + ((itemData.Stats and itemData.Stats.Comfort) or 0) * 0.15
								})

								attachData.Detached:Wait()
								status:Remove()
								animationHandler:StopAnimation(player.Character, "Bath")
							end
						end
					else
						return "Close"
					end
				end
			end
		}

	elseif interactionType == "Sink" then
		local data = object:WaitForChild("ObjectData")
		return {
			function()
				return "Wash Hands", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name)
						if itemData then
							if not object:FindFirstChild("AttachPos") or not object then
								local attachData = attachHandler:Attach(object.Parent.Parent, player.Character)
								if attachData then
									local waterSound = object.PrimaryPart:WaitForChild("Water")
									waterSound:Play()
									equipmentHandler:UnequipItem(player)
									animationHandler:PlayAnimation(player.Character, "WashHands")

									local status = localModules.StatHandler:AddStatus(player, {
										Name = "Clean as a Whistle",
										Color = "Great",
										Icon = itemData.Icon,
										Description = "It's important to clean your hands properly."
									}, {
										Hygiene = 2 + ((itemData.Stats and itemData.Stats.Hygiene) or 0) * 0.2
									})

									data.IsOn.Value = true
									attachData.Detached:Wait()
									waterSound:Stop()
									data.IsOn.Value = false
									status:Remove()
									animationHandler:StopAnimation(player.Character, "WashHands")
								end
							end
						end
					end
					return "Close"
				end
			end,
			function()
				return "Brush Teeth", 1, function(isServer)
					if isServer then
						local itemData = items:GetItem(object.Name)
						if itemData then
							if not object:FindFirstChild("AttachPos") or not object then
								local attachData = attachHandler:Attach(object.Parent.Parent, player.Character)
								if attachData then
									local waterSound = object.PrimaryPart:WaitForChild("Water")
									waterSound:Play()
									equipmentHandler:UnequipItem(player)
									animationHandler:PlayAnimation(player.Character, "BrushTeeth")

									local status = localModules.StatHandler:AddStatus(player, {
										Name = "Shining Teeth",
										Color = "Great",
										Icon = itemData.Icon,
										Description = "With those teeth you might blind others."
									}, {
										Hygiene = 2 + ((itemData.Stats and itemData.Stats.Hygiene) or 0) * 0.2
									})

									data.IsOn.Value = true
									attachData.Detached:Wait()
									data.IsOn.Value = false
									status:Remove()
									waterSound:Stop()
									animationHandler:StopAnimation(player.Character, "BrushTeeth")
								end
							end
						end
					end
					return "Close"
				end
			end
		}

	elseif type == "Fridge" then
		local equipped = equipmentHandler:GetEquipped(player)
		return {
			function()
				local plot = plotHandler:GetPlotFromModel(object)
				local plotOwner = plotHandler:GetPlayer(plot)
				if plot and plotOwner then
					return "View Content", 2, function(isServer)
						if isServer then
							local attachData = attachHandler:Attach(object, player.Character)
							if attachData then
								equipmentHandler:UnequipItem(player)
								animationHandler:PlayAnimation(player.Character, "UseFridge")
								animationHandler:PlayObjectAnimation(attachData.Model, "UseFridge")
								local data = dataManager:WaitEvent("TakeFridgeContent", player)
								attachData:Detach()
								animationHandler:StopAnimation(player.Character, "UseFridge")
								animationHandler:StopObjectAnimation(attachData.Model)

								local itemData = items:GetItem(data.Name)
								if itemData and plotOwner and localModules.StatHandler:RemoveFromInventory(plotOwner, itemData.Name, 1) then
									local model = equipmentHandler:EquipItem(player, itemData.Name)
									if model and itemData.Quantity then
										local quantity = Instance.new("IntValue")
										quantity.Name = "FoodQuantity"
										quantity.Value = itemData.Quantity
										quantity.Parent = model
										foodData:UpdatePlate(model, quantity.Value)
									end
								end
							end
						else
							if attachHandler:GetAttachPart(object, player.Character:WaitForChild("HumanoidRootPart").Position) then
								spawn(function()
									spawn(function()
										localModules.StorageHandler:ShowStorageFrame("Fridge", plotOwner)
									end)
									local selected = localModules.StorageHandler.StorageFrameClosed:Wait()
									dataManager:FireServer({ Type = "TakeFridgeContent", Name = selected and selected.Name or nil })
								end)
							end
							return "Close"
						end
					end
				end
			end,
			function()
				return "Take Ingredients", 1, function(isServer)
					if isServer then
						local attachData = attachHandler:Attach(object, player.Character)
						if attachData then
							equipmentHandler:UnequipItem(player)
							animationHandler:PlayAnimation(player.Character, "UseFridge")
							animationHandler:PlayObjectAnimation(attachData.Model, "UseFridge")
							local data = dataManager:WaitEvent("TakeIngredient", player)
							attachData:Detach()
							animationHandler:StopAnimation(player.Character, "UseFridge")
							animationHandler:StopObjectAnimation(attachData.Model)

							local thisFoodData = foodData.FoodIngredients[data.Name]
							if thisFoodData and thisFoodData.Price <= localModules.StatHandler:GetStat(player, "Money") then
								localModules.StatHandler:ChangeStat(player, "Money", -thisFoodData.Price)
								local model = equipmentHandler:EquipItem(player, thisFoodData.EquipModel)
								if model then
									local food = Instance.new("StringValue")
									food.Name = "FoodIngredient"
									food.Value = thisFoodData.Name
									food.Parent = model
								end
							end
						end
					else
						if attachHandler:GetAttachPart(object, player.Character:WaitForChild("HumanoidRootPart").Position) then
							spawn(function()
								spawn(function()
									localModules.CookingHandler:ShowIngredientFrame()
								end)
								local selected = localModules.CookingHandler.IngredientFrameClosed:Wait()
								dataManager:FireServer({ Type = "TakeIngredient", Name = selected and selected.Name or nil })
							end)
						end
						return "Close"
					end
				end
			end,
			function()
				local foodInfo = items.Data.Food[tostring(equipped)]
				local item, quantity = tostring(object), not equipped or not foodInfo or nil
				if (quantity and quantity == foodInfo.Quantity) or not quantity then
					return "Store " .. tostring(equipped), 2, function(isServer)
						if isServer then
							local plot = plotHandler:GetPlotFromModel(object)
							if plot then
								local plotOwner = plotHandler:GetPlayer(plot)
								if plotOwner and equipmentHandler:UnequipItem(player, equipped) then
									localModules.StatHandler:AddToInventory(plotOwner, foodInfo.Name, 1)
								end
							end
						else
							return "Close"
						end
					end
				end
			end
		}
	elseif type == "Stove" or type == "Grill" then
		return {
			function()
				local equipped = equipmentHandler:GetEquipped(player)
				if equipped and equipped:FindFirstChild("FoodIngredient") then
					local ingredientData = foodData.FoodIngredients[equipped.FoodIngredient.Value]
					if ingredientData and ingredientData.CookableAt[type] then
						return "Cook " .. tostring(ingredientData.Name), 1, function(isServer)
							if isServer then
								local attachData = attachHandler:Attach(object, player.Character)
								if attachData then
									if equipmentHandler:UnequipItem(player, equipped) then
										local animData = animationHandler:PlayAnimation(player.Character, ingredientData.CookableAt[type])
										animationHandler:PlayObjectAnimation(attachData.Model, ingredientData.CookableAt[type])

										local isCooked = true
										spawn(function()
											animData.Animation.Stopped:Wait()
											if isCooked then
												attachData:Detach()
												localModules.StatHandler:IncreaseSkill(player, "Cooking", ingredientData.CookingExp or 0)
												local model = equipmentHandler:EquipItem(player, ingredientData.Name)
												local cookedFoodData = items.Data.Food[ingredientData.Name]
												if cookedFoodData then
													local quantity = Instance.new("IntValue")
													quantity.Name = "FoodQuantity"
													quantity.Value = cookedFoodData.Quantity or 1
													quantity.Parent = model
												else
													warn("No item data for " .. tostring(ingredientData.Name))
												end
											end
										end)

										attachData.Detached:Wait()
										isCooked = false
										animationHandler:StopAnimation(player.Character, ingredientData.CookableAt[type])
										animationHandler:StopObjectAnimation(attachData.Model)
									else
										attachData:Detach()
									end
								end
								return "Close"
							end
						end
					end
				end
			end
		}


	elseif type == "Tables" or type == "Counters" then
	local equipped = equipmentHandler:GetEquipped(player)
	return {
		function()
			if equipped and items.Data.Food[tostring(equipped)] then
				local menuPos
				if menu then
					menuPos = menu:GetPosition()
					local target = menu.MouseTarget
					local canPlace = false

					if tostring(target) ~= "PlaceArea" then
						local placeObject
						if not equipped:FindFirstChild("Plate") and not equipped:FindFirstChild("Food") then
							placeObject = equipped:FindFirstChild("Food1")
						end
						if placeObject then
							local newTarget, newPos = workspace:FindPartOnRay(
								Ray.new(placeObject.Position, Vector3.new(0, -5, 0)),
								player.Character
							)
							if newTarget and newTarget:IsDescendantOf(object) then
								target = newTarget
								menuPos = newPos
							end
						end
					end

					if tostring(target) == "PlaceArea" then
						local surface = partAlign:GetSurface(target, target.Position + Vector3.new(0, 1000, 0))
						local pos = target.CFrame * CFrame.new(target.Size * 0.5 * Vector3.FromNormalId(surface))
						if pos.Y - 0.05 <= menuPos.Y then
							canPlace = true
						end
					end

					if not canPlace then
						return
					end

					return "Place " .. tostring(equipped), 1, function(isServer, clientData)
						local item = tostring(equipped)
						local quantity = equipped:FindFirstChild("FoodQuantity") and equipped.FoodQuantity.Value or nil

						if equipmentHandler:UnequipItem(player, equipped) then
							local didPlace = false
							local plot = plotHandler:GetPlotFromModel(object)
							local root = player.Character:FindFirstChild("HumanoidRootPart")

							if plot and root then
								local plotOwner = plotHandler:GetPlayer(plot)
								if plotOwner then
									didPlace = localModules.ObjectPlacer:PlaceObject(
										plotOwner,
										{
											Type = "PlaceObject",
											Name = item,
											Pos = clientData.Pos,
											Rot = math.pi * 0.5 - math.atan2(
												clientData.Pos.Z - root.Position.Z,
												clientData.Pos.X - root.Position.X
											),
											TargetModel = object
										},
										true
									)
								end
							end

							if not didPlace then
								local model = equipmentHandler:EquipItem(player, item)
								if quantity then
									local quantityValue = Instance.new("IntValue")
									quantityValue.Name = "FoodQuantity"
									quantityValue.Value = quantity
									quantityValue.Parent = model
								end
							else
								if quantity then
									didPlace:WaitForChild("ObjectData"):WaitForChild("FoodQuantity").Value = quantity
								end
								return "Close", { Pos = menuPos }
							end
						end
					end
				end
			end
		end
	}
	elseif type == "Food" then
	local objectData = object:FindFirstChild("ObjectData")
	local quantity = objectData and objectData:FindFirstChild("FoodQuantity") or nil
	local itemData = items:GetItem(object.Name)

	return {
		function()
			return "Take", 2, function(isServer)
				local item = tostring(object)
				local plot = plotHandler:GetPlotFromModel(object)
				local plotOwner = plotHandler:GetPlayer(plot)

				if localModules.ObjectPlacer:SellObject(plotOwner, object, true) then
					local model = equipmentHandler:EquipItem(player, item)
					if objectData and quantity then
						local quantityValue = Instance.new("IntValue")
						quantityValue.Name = "FoodQuantity"
						quantityValue.Value = quantity.Value
						quantityValue.Parent = model
						foodData:UpdatePlate(model, quantity.Value)
					end
				end
				return "Close"
			end
		end,
		function()
			if quantity and quantity.Value >= 1 and itemData.PortionItem then
				return "Take Portion", 1, function(isServer)
					local item = tostring(object)
					local plot = plotHandler:GetPlotFromModel(object)
					local plotOwner = plotHandler:GetPlayer(plot)

					quantity.Value = quantity.Value - 1
					if (quantity.Value < 1 and localModules.ObjectPlacer:SellObject(plotOwner, object, true)) or quantity.Value >= 1 then
						equipmentHandler:EquipItem(player, itemData.PortionItem)
					else
						quantity.Value = quantity.Value + 1
						return "Close"
					end
				end
			end
		end,
		function()
			if itemData.CanEat then
				return itemData.CanEat ~= true and itemData.CanEat or "Eat", 1, function(isServer)
					if isServer then
						local item = tostring(object)
						local plot = plotHandler:GetPlotFromModel(object)
						local plotOwner = plotHandler:GetPlayer(plot)

						if localModules.ObjectPlacer:SellObject(plotOwner, object, true) then
							local model = equipmentHandler:EquipItem(player, item)
							dataManager:FireLocal(player, { Type = "Eat", Item = model })
						end
					else
						return "Close"
					end
				end
			end
		end
	}
elseif object.Name == "Fruit Bowl" then
	return {
		function()
			return "Take Apple (2 $)", 1, function(isServer)
				if isServer then
					buyItem(player, "Apple", 2)
				else
					return "Close"
				end
			end
		end
	}
elseif type == "CoffeeMachine" then
	return {
		function()
			return "Make Coffee (3 $)", 1, function(isServer)
				if isServer then
					buyItem(player, "Coffee", 3)
				else
					return "Close"
				end
			end
		end
	}
elseif type == "IceCreamMachine" then
	return {
		function()
			return "Make Ice Cream (2 $)", 1, function(isServer)
				if isServer then
					buyItem(player, "Ice Cream", 2)
				else
					return "Close"
				end
			end
		end
	}
elseif type == "PunchingBag" then
	return {
		function()
			return "Punch", 1, function(isServer)
				if isServer then
					local itemData = items:GetItem(object.Name)
					if itemData then
						local attachData = attachHandler:Attach(object, player.Character)
						if attachData then
							equipmentHandler:UnequipItem(player)
							animationHandler:PlayAnimation(player.Character, "Punching")
							animationHandler:PlayObjectAnimation(attachData.Model, "Punching")

							local status = localModules.StatHandler:AddStatus(
								player,
								{
									Name = "Just like Rocky",
									Color = "Energized",
									Icon = itemData.Icon,
									Description = "Training your punches is great, as long as you only hit the bag."
								},
								{ Fun = 0.5, Energy = -1, Hygiene = -1 },
								{ Athletic = 0.85 }
							)

							attachData.Detached:Wait()
							status:Remove()
							animationHandler:StopAnimation(player.Character, "Punching")
							animationHandler:StopObjectAnimation(attachData.Model)
						end
					end
				else
					return "Close"
				end
			end
		end
	}
	
	else
		if type == "MailBox" then
			local plot = plotHandler:GetPlotFromModel(object)
			local plotOwner = plotHandler:GetPlayer(plot)

			if plotOwner == player then
				return {
					function()
						return "Manage Permissions", 1, function(isServer)
							spawn(function()
								localModules.HouseHandler:ShowPermissionFrame()
							end)
							return "Close", {NoSend = true}
						end
					end,

					function()
						return "Throw Party", 1, function(isServer)
							spawn(function()
								localModules.HouseHandler:ThrowParty()
							end)
							return "Close", {NoSend = true}
						end
					end,

					function()
						return "Enter Build Mode", 1, function(isServer)
							spawn(function()
								localModules.Hotbar:ToHouse()
								task.wait(0)
								localModules.Hotbar:EnterBuild()
							end)
							return "Close", {NoSend = true}
						end
					end
				}
			end

		elseif type == "Player" then
			if object == player then
				return {
					function()
						local emotes = {}
						for name, data in pairs(animationHandler:GetAnimationData()) do
							if name:sub(1, 6) == "Emote_" then
								table.insert(emotes, function()
									return name:sub(7), 1, function(isServer)
										if not isServer then
											animationHandler:PlayAnimation(player.Character, name)
											return "Close"
										end
									end
								end)
							end
						end
						return "Emotes...", 1, emotes
					end
				}
			else
				return {
					function()
						local plrPlot = plotHandler:GetPlot(player)
						if plotHandler:IsOnPlot(plrPlot, object) then
							return "Kick Out", 0, function(isServer)
								if isServer then
									local root = object.Character:WaitForChild("HumanoidRootPart")
									local targetPos = plotHandler:GetPlotSpawn(plrPlot)
									attachHandler:MovePlayer(object, targetPos * CFrame.new(0, 0, 6))
								else
									return "Close"
								end
							end
						end
					end,

					function()
						local permissionData = {}
						for index, role in ipairs(permissionHandler.PermissionRoles) do
							if role ~= "Owner" then
								table.insert(permissionData, function()
									return role, 0, function(isServer)
										if isServer then
											dataManager:FireLocal(player, {
												Type = "SetPermission",
												Index = index - 1,
												Player = object
											})
										else
											return "Close"
										end
									end
								end)
							end
						end
						return "Change Permission", 0, permissionData
					end,

					function()
						return "Donate Money", 0, function(isServer, clientData)
							if isServer then
								local amount = tonumber(clientData.Amount)
								if amount and amount > 0 and amount <= localModules.StatHandler:GetStat(player, "Money") then
									if localModules.StatHandler:ChangeStat(player, "Money", -amount) then
										localModules.StatHandler:ChangeStat(object, "Money", amount)
										if localModules.SaveHandler:SaveData(player, true) then
											dataManager:FireClient(object, {
												Type = "DonationReceived",
												Amount = amount,
												Sender = player
											})
											localModules.SaveHandler:SaveData(object)
										else
											-- rollback if save failed
											localModules.StatHandler:ChangeStat(object, "Money", -amount)
											localModules.StatHandler:ChangeStat(player, "Money", amount)
										end
									end
								end
							else
								local title = "Donate to '" .. tostring(object) .. "'"
								local money = tonumber(localModules.GUIHandler:InputBox(title, "Amount"))
								if not money or money <= 0 then
									localModules.GUIHandler:AlertBox("Invalid amount!", title)
								elseif localModules.ClientStats:Get("Money") < money then
									localModules.GUIHandler:AlertBox("You don't have enough money!", title)
								else
									if localModules.GUIHandler:ConfirmBox(
										"Are you sure you want to donate " .. textModule:SeparateNumber(money) .. " $ to '" .. tostring(object) .. "'?\nThis cannot be undone!",
										title
										) then
										return "Close", {Amount = money}
									end
								end
								return "Update", {NoSend = true}
							end
						end
					end
				}
			end
		end

	
	
end
end

		
		








return module