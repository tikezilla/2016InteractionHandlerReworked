-- params : ...

local module = {}
local players = game:GetService("Players")
local player = players.LocalPlayer
local storage = game:GetService("ReplicatedStorage")
local repModules = storage:WaitForChild("Modules")
require(repModules:WaitForChild("GlobalEnvironment"))()
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
local runService = game:GetService("RunService")
local inputService = game:GetService("UserInputService")
local GUI = player:WaitForChild("PlayerGui"):WaitForChild("MainGUI")
local modules = game:GetService("StarterGui"):WaitForChild("Modules")
local utils = repModules
local screenSpace = (require(utils:WaitForChild("ScreenSpace")))
local characterHandler = require(modules:WaitForChild("CharacterHandler"))
local statHandler = require(modules:WaitForChild("ClientStats"))
local inputManager = require(modules:WaitForChild("InputManager"))
local attachHandler = require(repModules:WaitForChild("AttachHandler"))
local getTarget = require(repModules:WaitForChild("GetTarget"))
local dataManager = require(repModules:WaitForChild("DataManager"))
local plotHandler = require(repModules:WaitForChild("PlotHandler"))
local permissionHandler = require(repModules:WaitForChild("PermissionHandler"))
local createChunk = require(repModules:WaitForChild("ChunkCreator"))

local statsFolder = game:GetService("Workspace"):WaitForChild("Stats")
local playerStat = statsFolder:WaitForChild(player.Name)  -- Wait for the player stat to exist

local isPlaying  -- Declare isPlaying outside so it's accessible later

local success, result = pcall(function()
	return playerStat:WaitForChild("IsPlaying")  -- This will block until the IsPlaying stat is available
end)

if success then
	isPlaying = result  -- If successful, set isPlaying
else
	warn("Error: IsPlaying stat not found for " .. player.Name)
	isPlaying = false  -- Handle the error as needed
end

-- Continue with your code using isPlaying
if isPlaying then
	-- Do something if the player is playing
else
	-- Handle the case where the player is not playing
end



local holder = (GUI:WaitForChild("InteractionMenu"))
local currentMenu = nil
module.Radius = 80
module.ButtonSize = 36
module.ButtonFontSize = 18
module.ButtonPadding = 30
module.TweenTime = 0.2
local thumbstickDeadzone = 0.1
local customData = {}
colorButton = function(btn, color)
  
  if btn then
    if btn:IsA("ImageButton") then
      if not color then
        btn.ImageColor3 = Color3.new(1, 1, 1)
        local background = btn:findFirstChild("Background")
        if background then
          if not color then
            background.ImageColor3 = Color3.new(1, 1, 1)
            for _,obj in pairs(btn:GetChildren()) do
              if obj:IsA("ImageLabel") and obj.Name ~= "ColorBox" then
                if not color then
                  do
                    obj.ImageColor3 = Color3.new(1, 1, 1)
                    -- DECOMPILER ERROR at PC54: LeaveBlock: unexpected jumping out IF_THEN_STMT

                    -- DECOMPILER ERROR at PC54: LeaveBlock: unexpected jumping out IF_STMT

                    -- DECOMPILER ERROR at PC54: LeaveBlock: unexpected jumping out IF_THEN_STMT

                    -- DECOMPILER ERROR at PC54: LeaveBlock: unexpected jumping out IF_STMT

                  end
                end
              end
            end
          end
        end
      end
    end
  end
end

module.GetMenu = function(self)
  
  return currentMenu
end

module.CloseMenu = function(self)
  
  if currentMenu then
    currentMenu:Close()
  end
end

module.CreateButton = function(self, text, parent, color)
  
  local button = script.Button:clone()
  button.Parent = parent
  button.Size = UDim2.new(0, 1000, 0, module.ButtonSize)
  button.Text = text
  button.FontSize = "Size" .. module.ButtonFontSize
  if color then
    button.ColorBox.Visible = true
    button.ColorBox.ImageColor3 = color
    button.Size = UDim2.new(0, button.TextBounds.X + module.ButtonPadding + (64 - module.ButtonPadding), 0, module.ButtonSize)
  else
    button.ColorBox.Visible = false
    button.Size = UDim2.new(0, button.TextBounds.X + module.ButtonPadding, 0, module.ButtonSize)
  end
  button.Position = UDim2.new(0, -button.AbsoluteSize.X * 0.5, 0, -button.AbsoluteSize.Y * 0.5)
  button.MouseEnter:connect(function()
    
    colorButton(button, Color3.new(0.9, 0.9, 0.9))
  end
)
  button.MouseLeave:connect(function()
    
    colorButton(button)
  end
)
  return button
end

local curMenu = 0

module.GetOrigin = function(self, target)
	if not target then
		warn("No target passed to GetOrigin")
		return nil, false
	end

	if target:IsA("Player") then
		local char = target.Character
		if char then
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if hrp then
				return hrp, true
			end
		end
	elseif target:IsA("Model") then
		-- Safe check for PrimaryPart
		local primary = target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
		if primary then
			local interactionOrigin = primary:FindFirstChild("CanInteract")
			if interactionOrigin and interactionOrigin:IsA("BoolValue") then
				if interactionOrigin.Value == true then
					return primary, true -- Custom origin
				else
					return primary, false -- Regular origin
				end
			else
				return primary, false -- No special InteractionOrigin
			end
		else
			warn("Model has no PrimaryPart or any BasePart: " .. target.Name)
			--return nil, false
		end
	elseif target:IsA("BasePart") then
		return target, false
	else
		warn("Unknown target type for GetOrigin: " .. tostring(target))
	end

	return nil, false
end




module.ShowMenu = function(self, target, mousePos, mouseTarget, data)
	if currentMenu and currentMenu.Target == target then
		module:CloseMenu()
		return
	end
	
	local selection = nil
	local char = characterHandler:GetCharacter()
	local attachWeld = attachHandler:GetAttachWeld(char)

	if target.Parent == char or (attachWeld and attachWeld.Part1:IsDescendantOf(target)) then
		return
	end

	module:CloseMenu()

	local menu = {}
	local isCustom = data ~= nil

	if not data then
		data = nil
	end

	if not data or #data == 0 then return end

	menu.Target = target
	menu.MouseTarget = mouseTarget
	menu.Path = ""
	menu.CreationTime = tick()
	menu.InteractionData = data
	menu.Center = script:WaitForChild("Center"):Clone()
	menu.Center.Parent = holder

	local origin, noOffset = module:GetOrigin(target)
	menu.OriginPart = origin

	function menu:UpdateOrigin()
		if not self.OriginPart or not self.OriginPart:GetRenderCFrame() then
			self.Origin = target:GetModelCFrame()
		else
			self.Origin = self.OriginPart:GetRenderCFrame()
		end
	end

	menu:UpdateOrigin()

	menu.Offset = (not noOffset and mousePos and self.Origin:Inverse() * mousePos) or CFrame.new()

	curMenu = (curMenu % 1000) + 1
	menu.ID = curMenu

	local plot = plotHandler:GetPlotFromModel(target)
	local permission = plot and permissionHandler:GetPlotPermission(plot, player) or 1
	local oldPath = menu.Path
	local isOpen = true

	function menu:IsOpen()
		return isOpen
	end

	function menu:GetPosition()
		self:UpdateOrigin()
		return self.Origin * self.Offset.p
	end

	function menu:IsWithinRange()
		local root = characterHandler:GetRoot(true)
		return root and (root.Position - self:GetPosition()).Magnitude < 10
	end

	menu.Data = {}
	menu.Buttons = {}

	function menu:Click(index)
		local indexData = self.Data[index]
		if indexData and indexData.Function then
			indexData.Function()
		end
	end

	function menu:Back()
		if self.Path == "" then
			self:Close()
		else
			self.Path = self.Path:match("(.+)/.+$") or ""
			self:Update()
		end
	end

	function menu:Update(isFirst)
		if not isOpen then return end

		for _, obj in ipairs(self.Center:GetChildren()) do
			obj:Destroy()
		end

		local curData, curIndex = nil
		self.Data = {}
		self.Buttons = {}

		for index, buttonFunc in pairs(curData) do
			local text, thisPermission, clickData, args = buttonFunc(target)
			if text and thisPermission <= permission then
				args = args or {}

				local function getPath()
					return (self.Path ~= "" and tostring(index)) and (self.Path .. "/" .. index) or tostring(index)
				end

				local function send(newSendData)
					if not args.NoSend and not isCustom then
						local sendData = { Type = "Interact", Target = target, Path = getPath() }
						if args.SendData then
							for k, v in pairs(args.SendData) do sendData[k] = v end
						end
						if newSendData then
							for k, v in pairs(newSendData) do sendData[k] = v end
						end
						if not sendData.NoSend then
							dataManager:FireServer(sendData)
						end
					end
				end

				local button = module:CreateButton(text, self.Center, args.Color)
				local function click()
					if type(clickData) == "function" then
						local action, sendData = clickData()
						send(sendData)
						if action == "Update" then
							self:Update()
						elseif action == "Close" then
							self:Close()
						end
					elseif type(clickData) == "table" then
						self.Path = getPath()
						self:Update()
					else
						send()
					end
				end

				button.MouseButton1Click:Connect(click)
				local buttonData = { Text = text, Function = click, Button = button, DataIndex = index }
				self.Data[index] = buttonData
				table.insert(self.Buttons, buttonData)
			end
		end

		if #self.Buttons == 0 then
			self:Close()
			return
		end

		local circleRadius = module.Radius
		while circleRadius * 2 / math.max(1, math.floor(#self.Buttons * 0.5)) < module.ButtonSize + 5 do
			circleRadius = circleRadius + 1
		end

		local isOnlyOne = #self.Buttons == 1
		for order, btnData in ipairs(self.Buttons) do
			local button = btnData.Button
			local delta = order / #self.Buttons
			local pos = Vector2.new(math.sin(delta * math.pi * 2), delta * 2)
			local width = button.AbsoluteSize.X

			button.Size = UDim2.new(0, 1, 0, 1)
			button.Position = UDim2.new()

			local x = pos.x * circleRadius + (isOnlyOne and -width * 0.5 or 0)
			local y = -circleRadius + pos.y * circleRadius * 2 - module.ButtonSize * 0.5

			button:TweenSizeAndPosition(
				UDim2.new(0, width, 0, module.ButtonSize),
				UDim2.new(0, x, 0, y),
				"Out", "Quad", module.TweenTime, true
			)
		end


		inputManager:RemoveSelection("InteractionMenu_" .. self.ID)
		inputManager:UnbindAction("InteractionMenu_" .. self.ID)
		inputManager:AddSelection("InteractionMenu_" .. self.ID, {})
		inputManager:BindAction("InteractionMenu_" .. self.ID, function(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.Begin then
				if inputObject.KeyCode == Enum.KeyCode.Backspace or inputObject.KeyCode == Enum.KeyCode.ButtonB then
					self:Back()
				elseif selection and inputObject.KeyCode == Enum.KeyCode.ButtonX then
					self:Click(selection.DataIndex)
				end
			elseif inputState == Enum.UserInputState.Change and inputObject.KeyCode == Enum.KeyCode.Thumbstick1 then
				local x, y = inputObject.Position.X, inputObject.Position.Y
				if thumbstickDeadzone < math.abs(x) or thumbstickDeadzone < math.abs(y) then
					local angle = (math.atan2(x, y) * 180 / math.pi + 360) % 360 / 360
					selection = self.Buttons[math.ceil((angle * #self.Buttons - 0.5) % #self.Buttons + 1)]
					inputManager:SetSelection(selection.Button, true)
				end
			end
		end, Enum.KeyCode.Backspace, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA, Enum.KeyCode.ButtonX, Enum.KeyCode.Thumbstick1)

		if inputManager:GetInputType() == "Gamepad" and self.Data[1] then
			inputManager:SetSelection(self.Data[1].Button, true)
		end
	end

	function menu:Close()
		if not isOpen then return end
		isOpen = false
		if currentMenu == self then
			currentMenu = nil
		end
		inputManager:RemoveSelection("InteractionMenu_" .. self.ID)
		inputManager:UnbindAction("InteractionMenu_" .. self.ID)

		if tick() - self.CreationTime <= 0.05 then
			self.Center:Destroy()
			runService:UnbindFromRenderStep("CircleMenu" .. self.ID)
		else
			for _, btn in ipairs(self.Center:GetChildren()) do
				btn:TweenSizeAndPosition(UDim2.new(0, 1, 0, 1), UDim2.new(), "In", "Quad", module.TweenTime, true)
			end
			delay(module.TweenTime, function()
				self.Center:Destroy()
				runService:UnbindFromRenderStep("CircleMenu" .. self.ID)
			end)
		end
	end

	function menu:UpdatePosition()
		if self:IsWithinRange() and isPlaying.Value then
			local screenPos, side = screenSpace.WorldToScreen(self:GetPosition())
			if side < 0 then
				self.Center.Visible = true
				self.Center.Position = UDim2.new(0, screenPos.x, 0, screenPos.y - screenSpace.TopbarHeight())
			else
				self.Center.Visible = false
			end
		else
			spawn(function() self:Close() end)
		end
	end

	runService:BindToRenderStep("CircleMenu" .. menu.ID, Enum.RenderPriority.Camera.Value + 50, function()
		menu:UpdatePosition()
	end)

	if menu:IsWithinRange() then
		currentMenu = menu
		menu:Update(true)
	else
		menu:Close()
	end

	return menu
end


local interactObjects = {}
local interactDynamicObjects = {}
local objectChunks = createChunk(10)

module.AddInteractObject = function(self, object)
	local origin, _ = module:GetOrigin(object)

	if not origin then
		warn("No origin for " .. tostring(object))
	end

	
	if object and object:IsA("BasePart") and object.Anchored then
		local isStatic = origin.Anchored
		
		if isStatic then
			objectChunks:AddObject(object)
		else
			table.insert(interactDynamicObjects, object)
		end

		local con, con2

		con = origin.Changed:Connect(function()
			if not origin then return end -- Extra safety

			if origin.Anchored ~= isStatic then
				if con then con:Disconnect() end
				if con2 then con2:Disconnect() end
				module:AddInteractObject(object)
			end
		end)

		con2 = object.AncestryChanged:Connect(function(_, parent)
			if not parent then
				if con then con:Disconnect() end
				if con2 then con2:Disconnect() end
				module:RemoveInteractObject(object)
			end
		end)
	end
end

module.RemoveInteractObject = function(self, object)
	local origin, _ = module:GetOrigin(object)

	if origin and origin.Anchored then
		objectChunks:RemoveObject(object)
	else
		for index, obj in pairs(interactDynamicObjects) do
			if obj == object then
				table.remove(interactDynamicObjects, index)
				break -- stop after finding it
			end
		end
	end
end


local function checkForObject()
	while true do
		local found = workspace:FindFirstChild("CanInteract", true)
		if found then
			interactObjects[found.Parent] = found
			found.Name = "CanInteract (Found)"
			break  -- Exit the loop once we find the object
		end
		wait(0.1)  -- Add a small delay
	end
end

-- Start the coroutine
coroutine.wrap(checkForObject)()

do
  for object,found in pairs(interactObjects) do
    found.Name = "CanInteract"
    module:AddInteractObject(object)
  end
  workspace.DescendantAdded:connect(function(found)
  
  if tostring(found) == "CanInteract" then
    module:AddInteractObject(found.Parent)
  end
end
)
	local lastX, lastZ = 0, 0
	local curChunks, lastObject, lastData, lastOffset, menuIndex = nil, nil, nil, nil, nil
	local interactIndicator = GUI:WaitForChild("InteractIndicator")

	local getMenu = function(object, offset, data)
		local plr = players:GetPlayerFromCharacter(object)
		offset = offset or Vector3.new()

		if plr then
			-- If the object is a player, just call ShowMenu with player
			return module:ShowMenu(plr, CFrame.new() + offset)
		else
			local origin = module:GetOrigin(object)
			if origin then
				-- Use customData if available and no data is passed
				if not data then
					data = customData[object]
				end
				return module:ShowMenu(object, origin.CFrame + offset, origin, data)
			end
		end
	end


  fastInteract = function()
  
  do
    if lastObject and not currentMenu and interactIndicator.Visible then
      local menu = getMenu(lastObject, lastOffset)
      if menu and menuIndex then
        menu:Click(menuIndex)
        if not menu:IsOpen() or #menu.Data <= 1 then
          menu:Close()
          runService:UnbindFromRenderStep("InteractTooltip")
          lastObject = nil
        end
        return true
      end
    end
    if currentMenu then
      currentMenu:Close()
      return true
    end
  end
end

  inputService.InputBegan:connect(function(obj, gameProcessed)
  
  if not gameProcessed and (obj.KeyCode.Name == "E" or obj.KeyCode.Name == "ButtonX") and isPlaying.Value then
    fastInteract()
  end
end
)
  spawn(function()
  
  while 1 do
    if wait(0.1) and isPlaying.Value then
      local root = characterHandler:GetRoot(true)
      do
        do
          if root then
            local pos = root.Position
            do
              local newX, newZ = objectChunks:GetChunkPosition(pos)
              if newX ~= lastX or newZ ~= lastZ or not curChunks then
                curChunks = objectChunks:GetChunks(pos, 1)
                table.insert(curChunks, interactDynamicObjects)
                local plrTable = {}
                for _,plr in pairs(players:GetPlayers()) do
                  do
                    if plr.Character and plr ~= player then
                      do
                        table.insert(plrTable, plr.Character)
                        -- DECOMPILER ERROR at PC58: LeaveBlock: unexpected jumping out IF_THEN_STMT

                        -- DECOMPILER ERROR at PC58: LeaveBlock: unexpected jumping out IF_STMT

                      end
                    end
                  end
                end
                table.insert(curChunks, plrTable)
              end
              do
                pos = root.Position + camera.CFrame.lookVector * 2
                local objectTable = {}
                local curObject = nil
                for _,chunk in pairs(curChunks) do
                  do
                    for _,obj in pairs(chunk) do
                      do
                        local origin = module:GetOrigin(obj)
                        if origin then
                          do
															table.insert(objectTable, {obj, (pos - origin.Position).Magnitude})


                            -- DECOMPILER ERROR at PC97: LeaveBlock: unexpected jumping out IF_THEN_STMT

                            -- DECOMPILER ERROR at PC97: LeaveBlock: unexpected jumping out IF_STMT

                          end
                        end
                      end
                    end
                  end
                end
                local curVisibllity = nil
                local setVisibility = function(show)
    
    if curVisibllity ~= show then
      curVisibllity = show
      if show then
        interactIndicator.Visible = true
        interactIndicator.Frame:TweenSizeAndPosition(UDim2.new(0, 36, 0, 36), UDim2.new(0, -18, 0, -18), "Out", "Quad", 0.05, true)
      else
        interactIndicator.Frame:TweenSizeAndPosition(UDim2.new(0, 1, 0, 1), UDim2.new(0, 0, 0, 0), "Out", "Quad", 0.05, true, function(status)
      
      if status == Enum.TweenStatus.Completed then
        interactIndicator.Visible = false
      end
    end
)
      end
    end
  end

                table.sort(objectTable, function(a, b)
    
    do return a[2] < b[2] end
    -- DECOMPILER ERROR: 1 unprocessed JMP targets
  end
)
                for _,data in ipairs(objectTable) do
                  local object, dist = data[1], data[2]
                  if object and dist < 6 then
                    if lastObject ~= object and not currentMenu then
                      local origin, noOffset = module:GetOrigin(object)
                      local isAttached = false
                      local char = characterHandler:GetCharacter()
                      local attachWeld = attachHandler:GetAttachWeld(char)
                      if object.Parent == char or attachWeld and attachWeld.Part1:IsDescendantOf(object) then
                        isAttached = true
                      end
                      local checkIntersects = function()
    
    local plot = plotHandler:GetClosestPlot(origin.Position, 20)
    if plot then
      return true
    end
  end

                      if not isAttached and not checkIntersects() then
                        curObject = object
                        runService:UnbindFromRenderStep("InteractTooltip")
                        lastObject = curObject
                        lastData = nil
                        lastOffset = Vector3.new(0, not noOffset and curObject:IsA("Model") and origin.CFrame:inverse() * curObject:GetModelCFrame().Y or 0, 0)
                        local curMenuButtons, curMenuText, curMenuIndex = 0, nil, nil
                        local intersects = false
                        local update = function()
    
    local testMenu = getMenu(lastObject, nil, lastData)
    curMenuButtons = 0
    lastData = nil
    intersects = false
    if testMenu then
      lastData = testMenu.InteractionData
      for index,data in pairs(testMenu.Data) do
        if data then
          if not curMenuIndex then
            curMenuIndex = index
          end
          curMenuButtons = curMenuButtons + 1
        end
      end
      testMenu:Close()
      if checkIntersects() then
        intersects = true
      end
    end
    menuIndex = curMenuButtons == 1 and curMenuIndex or nil
    interactIndicator.Frame.TextLabel.Text = menuIndex and curMenuText or "Interact"
    local inputType = inputManager:GetInputType()
    if inputType == "Touch" then
      interactIndicator.Frame.ImageTransparency = 1
      interactIndicator.Frame.Keybind.Visible = false
      interactIndicator.Frame.TextLabel.TextXAlignment = "Center"
      interactIndicator.Frame.TextLabel.Position = UDim2.new(0.5, -100, 0.12, 0)
    else
      interactIndicator.Frame.ImageTransparency = 0
      interactIndicator.Frame.Keybind.Visible = true
      interactIndicator.Frame.TextLabel.Position = UDim2.new(1, 7, 0.12, 0)
      interactIndicator.Frame.TextLabel.TextXAlignment = "Left"
      interactIndicator.Frame.Keybind.Text = inputType == "Gamepad" and "X" or "E"
    end
  end

                        update()
                        local lastUpdate = tick()
                        runService:BindToRenderStep("InteractTooltip", Enum.RenderPriority.Camera.Value + 50, function()
    
    local screenPos, side = screenSpace.WorldToScreen(origin.Position + lastOffset)
    if side < 0 and not currentMenu and isPlaying.Value then
      local now = tick()
      if now - lastUpdate > 0.5 then
        lastUpdate = now
        update()
      end
      if curMenuButtons > 0 and not intersects then
        setVisibility(true)
        interactIndicator.Position = UDim2.new(0, screenPos.x, 0, screenPos.y - screenSpace.TopbarHeight())
      else
        setVisibility(false)
      end
    else
      do
        setVisibility(false)
      end
    end
  end
)
                        break
                      end
                    else
                      do
                        do
                          if lastObject == object then
                            curObject = object
                          end
                          do break end
                          -- DECOMPILER ERROR at PC242: LeaveBlock: unexpected jumping out DO_STMT

                          -- DECOMPILER ERROR at PC242: LeaveBlock: unexpected jumping out IF_ELSE_STMT

                          -- DECOMPILER ERROR at PC242: LeaveBlock: unexpected jumping out IF_STMT

                          -- DECOMPILER ERROR at PC242: LeaveBlock: unexpected jumping out IF_THEN_STMT

                          -- DECOMPILER ERROR at PC242: LeaveBlock: unexpected jumping out IF_STMT

                        end
                      end
                    end
                  end
                end
                if not curObject then
                  do
                    if interactIndicator.Visible then
                      setVisibility(false)
                    end
                    runService:UnbindFromRenderStep("InteractTooltip")
                    lastObject = nil
                    lastData = nil
                    -- DECOMPILER ERROR at PC261: LeaveBlock: unexpected jumping out IF_THEN_STMT

                    -- DECOMPILER ERROR at PC261: LeaveBlock: unexpected jumping out IF_STMT

                  end
                end
              end
            end
          end
          -- DECOMPILER ERROR at PC263: LeaveBlock: unexpected jumping out DO_STMT

          -- DECOMPILER ERROR at PC263: LeaveBlock: unexpected jumping out IF_THEN_STMT

          -- DECOMPILER ERROR at PC263: LeaveBlock: unexpected jumping out IF_STMT

        end
      end
    end
  end
end
)
	module.AddInteraction = function(self, object, data)
		if object then
			customData[object] = data

			local canInteract = object:FindFirstChild("CanInteract")
			if not canInteract then
				canInteract = Instance.new("BoolValue")
				canInteract.Name = "CanInteract"
				canInteract.Value = true
				canInteract.Parent = object
			else
				canInteract.Value = true
			end

			module:AddInteractObject(object)
		else
			warn("AddInteraction: Object is nil")
		end
	end


  module.RemoveInteraction = function(self, object)
  
  if currentMenu and currentMenu.Target == object then
    currentMenu:Close()
  end
  customData[object] = nil
  local canInteract = object:findFirstChild("CanInteract")
  if canInteract then
    canInteract:Destroy()
  end
  module:RemoveInteractObject(object)
end

  inputService.InputBegan:connect(function(input, gameProcessed)
  
  if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and not gameProcessed and isPlaying.Value then
    local target = mouse.Target
    if target then
      local parent = target.Parent
      local object, type = getTarget(parent, player, target)
      if inputManager:GetInputType() == "Touch" and lastObject == object and fastInteract() then
        return 
      end
      if object and object:findFirstChild("CanInteract") then
        module:ShowMenu(object, mouse.Hit, target)
        return 
      else
        for hookedObject,data in pairs(customData) do
          if target == hookedObject or target:IsDescendantOf(hookedObject) then
            module:ShowMenu(hookedObject, mouse.Hit, target, data)
            return 
          end
        end
        local mouseRay = camera:ScreenPointToRay(mouse.X, mouse.Y, 1)
        for _,plr in pairs(players:GetPlayers()) do
						if (plr == player and (camera.CoordinateFrame.p - plr.Character.PrimaryPart.Position).Magnitude > 4.5) or plr ~= player then
            local root = plr.Character:findFirstChild("HumanoidRootPart")
            if root and mouseRay:Distance(root.Position) < 3 then
              module:ShowMenu(plr, mouse.Hit)
              return 
            end
          end
        end
      end
    end
    do
      module:CloseMenu()
    end
  end
end
)
  inputManager.InputTypeChanged:connect(function(type)
  
  if type == "Gamepad" then
    module.ButtonSize = 48
    module.ButtonFontSize = 24
  else
    module.ButtonSize = 36
    module.ButtonFontSize = 18
  end
  if currentMenu then
    currentMenu:Update()
  end
end
)
  return module
end
