-- GUI Handler MADE by Caleb on April 20th, 2025
local module = {}
local players = game:GetService("Players")
local player = players.LocalPlayer
local storage = game:GetService("ReplicatedStorage")
local GUI = player:WaitForChild("PlayerGui"):WaitForChild("MainGUI")
local modules = game.StarterGui.Modules
local sounds = require(modules:WaitForChild("SoundHandler"))
local inputManager = require(modules:WaitForChild("InputManager"))
local runService = game:GetService("RunService")
local interpolate = require(game.ReplicatedStorage.Modules:WaitForChild("Interpolate"))
local renderStepped = runService.RenderStepped
local curActive = {}
local curQueued = {}

local promptFade = 0.5

module.HoverEffect = function(self, obj, intensity)
	-- Ensure the object exists and is of type 'GuiObject' (TextButton, ImageButton, etc.)
	-- Default intensity to 0.9 if not provided
	intensity = tonumber(intensity) or 0.9

	-- Determine the correct property to change based on object type (Image or Text)
	if obj then
		local property = (obj:IsA("ImageButton") or obj:IsA("ImageLabel")) and "ImageColor3" or "TextColor3"
		
		local originalColor = obj[property]

		-- Function to apply the dimming effect on hover
		local function applyDim()
			if obj.Parent then  -- Ensure the object hasn't been removed
				obj[property] = Color3.new(
					originalColor.R * intensity,
					originalColor.G * intensity,
					originalColor.B * intensity
				)
			end
		end

		-- Function to reset the color when the mouse leaves
		local function resetColor()
			if obj.Parent then  -- Ensure the object hasn't been removed
				obj[property] = originalColor
			end
		end

		-- Connect the hover effect to MouseEnter/Leave events
		obj.MouseEnter:Connect(applyDim)
		obj.MouseLeave:Connect(resetColor)

		-- Connect for when the object gains or loses selection (for controllers or keyboard navigation)
		obj.SelectionGained:Connect(applyDim)
		obj.SelectionLost:Connect(resetColor)
	end
end

module.HoverButtonEffect = function(self, obj)
	assert(obj:IsA("GuiButton"), "Object must be a 'GuiButton'")
	module:HoverEffect(obj)
end

for _, button in pairs(game.Players.LocalPlayer.PlayerGui.MainGUI:GetDescendants()) do
	if button:IsA("GuiButton") then
		module:HoverButtonEffect(button)
	end
end

		

module.RoundedButtonEffect = function(self, obj)

	assert(obj:IsA("GuiButton"), "Object must be a \'GuiObject\'")
	local content = {}
	for _,objContent in pairs(obj:GetChildren()) do
		content[objContent] = objContent.Position
	end
	module:HoverEffect(obj)
	obj.MouseButton1Down:connect(function()

		--obj.Image = "rbxassetid://337251609"
		for objContent,pos in pairs(content) do
			objContent.Position = UDim2.new(pos.X.Scale, pos.X.Offset, pos.Y.Scale, pos.Y.Offset + 2)
		end
	end
	)
	local clickUp = function()

		--obj.Image = "rbxassetid://295943248"
		for objContent,pos in pairs(content) do
			objContent.Position = pos
		end
	end

	obj.MouseButton1Up:connect(clickUp)
	obj.MouseLeave:connect(clickUp)
end

local queueChanged = Instance.new("BindableEvent", script)
queueChanged.Name = "QueueChanged"
module.Queue = function(self, func, priority, ...)
	priority = tonumber(priority) or 10

	if not curActive[priority] then
		curActive[priority] = 0
	end
	if not curQueued[priority] then
		curQueued[priority] = -1
	end

	local queueNum = curQueued[priority] + 1
	curQueued[priority] = queueNum
	
	local waitForTurn = function()
		while queueNum ~= curActive[priority] do
			queueChanged.Event:Wait() 
		end
	end
	waitForTurn()

	local args = {func(...)} 

	curActive[priority] = curActive[priority] + 1
	queueChanged:Fire() 

	return unpack(args)
end

local function createInputBox(title, defaultValue, GUI, promptFade, inputManager)
	local oldframe = player.PlayerGui.MainGUI:FindFirstChild("InputBox")
	if oldframe then
		oldframe:Destroy()
	end
	local frame = script.InputBox:Clone()
	frame.Parent = GUI
	frame.Title.Text = title
	frame.ContentBox.Text = defaultValue or "..."
	local overlay = frame.Overlay
	frame.Visible = true

	overlay.BackgroundTransparency = 1
	frame.Position = UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0)

	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 0.5, -frame.AbsoluteSize.Y * 0.5),
		Enum.EasingDirection.In,
		Enum.EasingStyle.Sine,
		promptFade
	)

	for t = 0, 1, 0.1 do
		overlay.BackgroundTransparency = 1 - 0.5 * t
		task.wait(0.05)
	end

	-- Wait for "Ok" button with a timeout
	local okButton = frame:WaitForChild("Ok", 999999999999999)  -- 5-second timeout
	if okButton then
		local clickEvent = Instance.new("BindableEvent", frame)
		okButton.MouseButton1Click:Connect(function()
			clickEvent:Fire(true)
		end)

		inputManager:AddSelection("InputBox", { frame.ContentBox })
		inputManager:BindAction(
			"InputBox",
			function(actionName, inputState)
				if inputState == Enum.UserInputState.Begin then
					clickEvent:Fire(true)
				end
			end,
			false,
			Enum.KeyCode.Backspace,
			Enum.KeyCode.Return,
			Enum.KeyCode.ButtonB,
			Enum.KeyCode.ButtonA
		)

		local input = clickEvent.Event:Wait()

		-- Cleanup after input
		inputManager:UnbindAction("InputBox")
		inputManager:RemoveSelection("InputBox")

		frame:TweenPosition(
			UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0),
			Enum.EasingDirection.Out,
			Enum.EasingStyle.Sine,
			promptFade,
			true,
			function()
				frame.Visible = false
			end
		)

		for t = 0, 1, 0.1 do
			overlay.BackgroundTransparency = 0.5 + 0.5 * t
			task.wait(0.05)
		end

		return frame.ContentBox.Text
	else
		warn("InputBox's 'Ok' button not found within the timeout!")
	end
end

module.CreateInputBox = createInputBox



module.CreateInputBox = createInputBox

local function createMessageBox(content, title, color)
	-- Clone the MessageBox and set its parent
	local frame = script.MessageBox:Clone()
	frame.Parent = GUI

	-- Set title and content
	frame.Title.Text = title or "Message"
	frame.Content.Text = content or "..."

	-- Adjust the frame's size
	local sizeDiff = frame.AbsoluteSize.Y - frame.Content.AbsoluteSize.Y
	frame.Size = UDim2.new(frame.Size.X.Scale, frame.Size.X.Offset, 0, frame.Content.TextBounds.Y + sizeDiff)

	-- Set colors
	color = color or Color3.new(0, 0.66666666666667, 1)
	frame.Ok.ImageColor3 = color
	frame.Title.TextColor3 = color

	-- Prepare for animation
	local overlay = frame.Overlay
	overlay.BackgroundTransparency = 1
	frame.Visible = true
	frame.Position = UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0)

	-- Slide in animation
	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 0.5, -frame.AbsoluteSize.Y * 0.5),
		Enum.EasingDirection.In,
		Enum.EasingStyle.Sine,
		promptFade
	)

	interpolate(promptFade, "In", "Quad", function(t)
		overlay.BackgroundTransparency = 1 - 0.5 * t
	end, true)

	-- Add button effect and bind click event
	module:RoundedButtonEffect(frame.Ok)
	local clickEvent = Instance.new("BindableEvent")
	frame.Ok.MouseButton1Down:Connect(function()
		clickEvent:Fire(true)
	end)

	-- Bind actions for keyboard/gamepad inputs
	inputManager:AddSelection("MessageBox", { frame.Ok })
	inputManager:BindAction("MessageBox", function(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Begin then
			clickEvent:Fire(true)
		end
	end, false, Enum.KeyCode.Backspace, Enum.KeyCode.Return, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	-- Wait for user input
	local input = clickEvent.Event:Wait()

	-- Cleanup after interaction
	inputManager:UnbindAction("MessageBox")
	inputManager:RemoveSelection("MessageBox")

	-- Slide out animation
	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0),
		Enum.EasingDirection.Out,
		Enum.EasingStyle.Sine,
		promptFade,
		true,
		function()
			frame:Destroy()
		end
	)

	interpolate(promptFade, "Out", "Quad", function(t)
		overlay.BackgroundTransparency = 0.5 + 0.5 * t
	end, true)

	return true
end

module.createMessageBox = createMessageBox


module.Open = function(frame, overlay, duration)
	duration = duration or 0.5
	
	frame.Visible = true
	frame.Position = UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0)
	game:GetService("RunService").Heartbeat:Wait()
	
	if overlay then
		interpolate(promptFade, "In", "Quad", function(t)
			overlay.BackgroundTransparency = 1 - 0.5 * t
		end, true)
	end

	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 0.5, -frame.AbsoluteSize.Y * 0.5),
		Enum.EasingDirection.In,
		Enum.EasingStyle.Sine,
		duration,
		true
	)
end

module.Close = function(frame, overlay, duration, callback)
	duration = duration or 0.5
	
	local tweencomplete = false
	local fadecomplete = not overlay
	
	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0),
		Enum.EasingDirection.Out,
		Enum.EasingStyle.Sine,
		duration,
		true,
		function()
			tweencomplete = true
			if tweencomplete and fadecomplete then
				frame.Visible = false
				if callback then callback() end
			end
		end
	)

	if overlay then
		interpolate(promptFade, "Out", "Quad", function(t)
			overlay.BackgroundTransparency = 0.5 + 0.5 * t
		end, true)
		
		task.delay(duration, function()
			fadecomplete = true
			if tweencomplete and fadecomplete then
				frame.Visible = false
				if callback then callback() end
			end
		end)
	end
end

module.AlertBox = function(self, content, title)

	return module:Queue(createMessageBox, nil, content, title, Color3.new(1, 0.19607843137255, 0))
end

local RunService = game:GetService("RunService")

-- Assumes: GUI, promptFade, interpolate, module, inputManager are defined above this function.

local function createConfirmBox(content, title)
	local frame = script.ConfirmBox:Clone()
	frame.Parent = GUI
	frame.Visible = true

	-- Setup basic text
	frame.Title.Text = title or "Are you sure?"
	frame.Content.Text = content or "..."

	-- Temporarily scale to allow layout measuring
	frame.Size = UDim2.new(frame.Size.X.Scale, frame.Size.X.Offset, 10, 0)

	-- Wait a frame to allow AbsoluteSize/TextBounds to update
	RunService.RenderStepped:Wait()

	local sizeDiff = frame.AbsoluteSize.Y - frame.Content.AbsoluteSize.Y
	frame.Size = UDim2.new(frame.Size.X.Scale, frame.Size.X.Offset, 0, frame.Content.TextBounds.Y + sizeDiff)

	local overlay = frame.Overlay
	overlay.BackgroundTransparency = 1

	-- Animate in
	frame.Position = UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0)
	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 0.5, -frame.AbsoluteSize.Y * 0.5),
		"In", "Sine", promptFade
	)
	interpolate(promptFade, "In", "Quad", function(t)
		overlay.BackgroundTransparency = 1 - 0.5 * t
	end, true)

	-- Button effects and events
	local clickEvent = Instance.new("BindableEvent", frame)

	module:RoundedButtonEffect(frame.Yes)
	module:RoundedButtonEffect(frame.No)

	frame.Yes.MouseButton1Down:Connect(function()
		clickEvent:Fire(true)
	end)
	frame.No.MouseButton1Down:Connect(function()
		clickEvent:Fire(false)
	end)

	-- Controller/keyboard support
	inputManager:AddSelection("ConfirmBox", {})
	inputManager:BindAction("ConfirmBox", function(_, inputState, input)
		if inputState == Enum.UserInputState.Begin then
			if input.KeyCode == Enum.KeyCode.Return or input.KeyCode == Enum.KeyCode.ButtonA then
				clickEvent:Fire(true)
			else
				clickEvent:Fire(false)
			end
		end
	end, false, Enum.KeyCode.Backspace, Enum.KeyCode.Return, Enum.KeyCode.ButtonB, Enum.KeyCode.ButtonA)

	-- Await result
	local input = clickEvent.Event:Wait()

	-- Cleanup
	inputManager:UnbindAction("ConfirmBox")
	inputManager:RemoveSelection("ConfirmBox")
	frame:TweenPosition(
		UDim2.new(0.5, -frame.AbsoluteSize.X * 0.5, 1, 0),
		"Out", "Sine", promptFade, true,
		function()
			frame:Destroy()
		end
	)
	interpolate(promptFade, "In", "Quad", function(t)
		overlay.BackgroundTransparency = 0.5 + 0.5 * t
	end, true)

	return input
end

-- Wrap with module function
module.ConfirmBox = function(self, ...)
	return module:Queue(createConfirmBox, nil, ...)
end


return module

